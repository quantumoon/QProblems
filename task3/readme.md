1) Сначала с помощью ноутбука embedder-for-qml.ipynb производим предобработку. Используя библиотеку SentenceTransformers, мы строим информативные векторные (размер 384) представления для наших комментариев. Также в этом же ноутбуке для последующего квантового алгоритма мы обучаем классический автоэнкодер на сжатие вектора размера 384 в NUM_QUBITS (=4 в этой задача)


2) Далее в ноутбуке classical.ipynb задача решается классическим образом на основе полученных эмбеддингов предложений. Мы построили простейшую сеть с одним линейным слоем и оучили ее на задачу классификации


3) Скрипт pyideem-qml-train-test.py использовался нами для обучения квантового вариационного алгоритма (ZZFeatureMap + RealAmplitudeAnsatz) на задачу бинарной классификации на бэкенде pyideem. Результатами его выполнения являются зависимости функции потерь от числа итераций для трейновой и тестовой выборок (разделенных собственноручно), а также набор оптимальных параметров


4) Последний ноутбук qml.ipynb инициализирует квантовую цепочку с оптимальными параметрами, найденными ранее, отрисовывает функции потерь от числа итераций и считает метрику accuracy
